# app/services/task_service.py
from typing import List, Optional

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import asc, desc, or_

from app.models.task import Task, StatusEnum, PriorityEnum
from app.schemas.task import TaskCreate, TaskUpdate, TaskRead


async def create_tasks(db: AsyncSession, tasks: List[TaskCreate]) -> List[TaskRead]:
    created: List[Task] = []
    for t in tasks:
        # Avoid duplicates based on source_id
        if t.source_id:
            q = await db.execute(select(Task).where(Task.source_id == t.source_id))
            if q.scalar_one_or_none():
                continue

        task = Task(**t.model_dump())
        db.add(task)
        created.append(task)

    await db.commit()
    # Refresh to populate autogenerated fields (id, timestamps)
    for task in created:
        await db.refresh(task)

    return [TaskRead.model_validate(task) for task in created]


async def list_tasks(db: AsyncSession) -> List[TaskRead]:
    result = await db.execute(select(Task))
    tasks = result.scalars().all()
    return [TaskRead.model_validate(t) for t in tasks]


async def update_task(
    db: AsyncSession, task_id: str, patch: TaskUpdate
) -> Optional[TaskRead]:
    task = await db.get(Task, task_id)
    if not task:
        return None

    for field, value in patch.model_dump(exclude_unset=True).items():
        setattr(task, field, value)

    await db.commit()
    await db.refresh(task)

    return TaskRead.model_validate(task)


async def delete_task(db: AsyncSession, task_id: str) -> bool:
    task = await db.get(Task, task_id)
    if not task:
        return False

    await db.delete(task)
    await db.commit()
    return True


async def filter_tasks(
    db: AsyncSession,
    status: Optional[StatusEnum] = None,
    priority: Optional[PriorityEnum] = None,
    keyword: Optional[str] = None,
    tags: Optional[List[str]] = None,
    sort_by: str = "created_at",
    order: str = "desc",
    match_all_tags: bool = True,  # NEW: choose AND/OR behavior
) -> List[TaskRead]:
    query = select(Task)

    if status:
        query = query.where(Task.status == status)
    if priority:
        query = query.where(Task.priority == priority)
    if keyword:
        query = query.where(Task.text.ilike(f"%{keyword}%"))
    if tags:
        if match_all_tags:
            # Require ALL tags (AND)
            for tag in tags:
                query = query.where(Task.tags.contains([tag]))
        else:
            # Match ANY tag (OR)
            query = query.where(or_(*[Task.tags.contains([tag]) for tag in tags]))

    # Sorting with safe fallback
    sort_column = getattr(Task, sort_by, Task.created_at)
    if order.lower() == "asc":
        query = query.order_by(asc(sort_column))
    else:
        query = query.order_by(desc(sort_column))

    result = await db.execute(query)
    tasks = result.scalars().all()
    return [TaskRead.model_validate(t) for t in tasks]
